@startuml

' The diagram describes a use-case where
' the system experienced transient
' a failure. One of the nodes lost its volatile
' state, and leads to the DTM "recovering" procedures.
' The goal of the diagram is to show the interactions
' between CAS client/service and DTM library/service
' and the HA.

header DTM One Transient \n By Ivan A. 2020-14-12.
footer Page %page% of %lastpage%

title DTM One Transient

' The types of processes used here:
' 	- Originators (participants without peristent storage)
' 	- Participants (participants with persistent storage).

box "Client (0)" #00ffcc
	participant "Motr Client" as user
	participant "DIX0" as DIX0
	participant "DTM0" as DTM0
	participant "HA0" as HA0
end box

box "ServerLeft (1)" #b3daff
	participant "CAS1" as CAS1
	participant "DTM1" as DTM1
	participant "HA1" as HA1
end box

box "ServerMiddle (2)"   #66b5ff
	participant "CAS2" as CAS2
	participant "DTM2" as DTM2
	participant "HA2" as HA2
end box

box "ServerRight (3)"   #339cff
	participant "CAS3" as CAS3
	participant "DTM3" as DTM3
	participant "HA3" as HA3
end box

' Prepare op and start execution on (1) 2{{{

user -> DIX0: clnt_op = { op=PUT, records=k1-k16,v1-v6 }
DIX0 -> CAS1: GET_LAYOUT_AND_PVER
CAS1 -> DIX0: layout_info (pool version, layout id, etc.)
DIX0 -> DIX0: layout = clnt_op.records.map(m0_dix_target_(layout_info, record))
DIX0 -> DTM0: dtx_open(...) returns dtx { clock: now(), tx_id: new_id() }
DIX0 -> DTM0: dtx.add_and_close(pa_p=layout, pa_v=DIX0.fid)
DTM0 -> DTM0: dtx = { clock, tx_id, \npa_v=self.fid,\n pa_p=layout,\n states[1:3]=[FUTURE] }
DIX0 -> DIX0: dix_req[1:3] = { dtx, layout, records, src: DIX0.fid, dst: CAS[i].fid }
DIX0 -> DTM0: dtx_prepared(dtx, dix_req[])
DTM0 -> DTM0: dtx.states = [PREPARED] * 3
DTM0 -> DIX0: ok, ready
' 2}}}

group Sending requests 
	DIX0 -> CAS1: send(dix_req[1])
	DIX0 -> DTM0: dtx_inprogress(dtx, dix_req[1])
	DIX0 -> CAS2: send(dix_req[2])
	DIX0 -> DTM0: dtx_inprogress(dtx, dix_req[2])
	DIX0 -> CAS3: send(dix_req[3])
	DIX0 -> DTM0: dtx_inprogress(dtx, dix_req[3])
end

group CAS1 execution
	CAS1 -> DTM1: dtx_recv(fom.fop.request.dtx)
	DTM1 -> CAS1: returns (dtx, ready)
	CAS1 -> CAS1: FOM_TX_OPEN: fom.ltx = be_tx.open()
	CAS1 -> CAS1: FOM_CAS_LOOP: cas_reply = cas_exec(fom)
	CAS1 -> CAS1: FOM_SUCCESS: fom.fop.reply = cas_reply
	CAS1 -> DTM1: FOM_FOL_REC_ADD: dtm_log_add(fom)
	CAS1 -> CAS1: FOM_TX_COMMIT: fom.ltx.close()
	CAS1 -> CAS1: FOM_QUEUE_REPLY: rpc_post(fom.fop.reply)
	CAS1 -> DIX0: send reply "EXECUTED" {dtx, cas_reply}
	DIX0 -> DTM0: dtx_executed(reply.dtx)
	DIX0 -> user: lookup_op(reply.dtx).on_executed()
end 

=== Server (1) powered off ===

group  Server (1) got crached
	CAS1 ->X HA1: No heartbeats
	DTM1 ->X HA1: No heartbeats
	CAS1 -> CAS1: Lost volatile state
	DTM1 -> DTM1: Lost volatile state
end

group CAS2 execution 
	CAS2 -> DTM2: dtx_recv
	CAS2 -> CAS2: execute ...
	CAS2 -> DTM2: dtm_log_add(fom)
	CAS2 -> DIX0: send reply "EXECUTED" {dtx, cas_reply}
end
 
group CAS2 persistent 
	CAS2 -> DTM2: dtm_log_persistent(dtx, [pa=self])
	DTM2 -> DTM0: send(PERSISTENT, dtx)
	DTM0 -> DIX0: on_persistent(dtx)
	DIX0 -> user: lookup_op(dtx).on_persistent()
	DTM2 ->X DTM1: send(PERSISTENT, dtx)
	DTM2 -> DTM3: send(PERSISTENT, dtx)
end

group CAS3 execution 
	CAS3 -> DTM3: dtx_recv
	CAS3 -> CAS3: execute ...
	CAS3 -> DTM3: dtm_log_add(fom)
	CAS3 -> DIX0: send reply "EXECUTED" {dtx, cas_reply}
end
 
group CAS3 persistent 
	CAS3 -> DTM3: dtm_log_persistent(dtx, [pa=self])
	DTM3 -> DTM0: send(PERSISTENT, dtx)
	DTM3 ->X DTM1: send(PERSISTENT, dtx)
	DTM3 -> DTM2: send(PERSISTENT, dtx)
end

=== Server (1) powered on ===

group Server(1) enters "recovering" of records until E
	CAS1 -> DTM1: Ready for DTM redo @E
	note right: @E is the point where CAS1 \nis ready to receive requests
	DTM1 -> HA1: Ready for DTM redo @E
	HA1 -> HA0: Server(1) is ready for redo @E
	HA1 -> HA2: Server(1) is ready for redo @E
	HA1 -> HA3: Server(1) is ready for redo @E
end

group REDO from Server(2)
	HA2 -> DTM2: REDO Server(1)@E
	loop forall dtx in log until dtx.clock < @E
		DTM2 -> DTM1: send(REDO, dtx, seqid, max_seqid)
		DTM1 -> DTM1: dtx_recv
		DTM1 -> CAS1: execute ...
		CAS1 -> DTM1: dtm_log_add(fom, persistent=dtx.state)
	end
	DTM1 -> HA1: done REDO from Server(2)@E
end

group REDO from Client (0)
	HA0 -> DTM0: REDO Server(1)@E
	loop forall dtx in log until dtx.clock < @E
		DTM0 -> DTM1: send(REDO, dtx, seqid, max_seqid)
		DTM1 -> DTM1: dtx_recv(dtx, ...)
		DTM1 -> DTM1: dtm_log_lookup(dtx.tx_id) -> record\ndup detected
		DTM1 -> CAS1: cas_reply = record.reply
		CAS1 -> DIX0: send reply "EXECUTED" {dtx, cas_reply}
		CAS1 -> DTM1: dtm_log_add(fom, persistent=dtx.state)
	end
	DTM1 -> HA1: done REDO from Client(0)@E
end

group REDO from Server(3)
	HA2 -> DTM3: REDO Server(1)@E
	loop forall dtx in log until dtx.clock < @E
		DTM3 -> DTM1: send(REDO, dtx, seqid, max_seqid)
		DTM1 -> DTM1: dtm_log_lookup(dtx.tx_id) -> record\ndup detected
		DTM1 -> DTM1: dtm_log_add(fom, persistent=dtx.state)
	end
	DTM1 -> HA1: done REDO from Server(1)@E
end

group Presistent notices from the recovering server.\nThey can be sent at any moment\nduring recovery.
	' Self
	CAS1 -> DTM1: dtm_log_persistent(dtx, [pa=self])
	DTM1 -> DTM1: on_stable(dtx)
	' Client(0)
	DTM1 -> DTM0: send(PERSISTENT, dtx)
	DTM0 -> DTM0: dtm_log_persistent(dtx, pa=CAS1)
	DTM0 -> DTM0: dtm_log_stable(dtx)
	DTM0 -> DIX0: on_stable(dtx)
	DIX0 -> user: lookup_op(dtx).on_stable()
	' Server(2)
	DTM1 -> DTM2: send(PERSISTENT, dtx)
	DTM2 -> DTM2: dtm_log_persistent(dtx, pa=CAS1)
	DTM2 -> DTM2: dtm_log_stable(dtx)
	' Server(3)
	DTM1 -> DTM3: send(PERSISTENT, dtx)
	DTM3 -> DTM3: dtm_log_persistent(dtx, pa=CAS1)
	DTM3 -> DTM3: dtm_log_stable(dtx)
end

=== Server (1) enters ONLINE ===

group HA notifies about Online state for Server(1)
	HA1 -> HA0: Server(1) is Online
	HA1 -> HA2: Server(1) is Online
	HA1 -> HA3: Server(1) is Online
end

@enduml
' vim: textwidth=80 nowrap foldmethod=marker
